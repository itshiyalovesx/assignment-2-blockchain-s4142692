import hashlib
import json
import time
import ecdsa
import os
import glob
import pickle
from datetime import datetime
from uuid import uuid4

# --- Cryptographic Utilities ---

class Wallet:
    """Manages public/private key pairs for users."""
    
    def __init__(self):
        self.private_key = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1)
        self.public_key = self.private_key.get_verifying_key()
        self.address = self.public_key.to_string().hex()

    def sign_transaction(self, transaction_data):
        """Signs a transaction with the wallet's private key."""
        return self.private_key.sign(transaction_data.encode()).hex()

    def verify_signature(self, public_key, signature, transaction_data):
        """Verifies a transaction's signature using the sender's public key."""
        try:
            vk = ecdsa.VerifyingKey.from_string(bytes.fromhex(public_key), curve=ecdsa.SECP256k1)
            return vk.verify(bytes.fromhex(signature), transaction_data.encode())
        except ecdsa.BadSignatureError:
            return False

# --- Transaction and UTXO Management ---

class Transaction:
    """Represents a transaction in the blockchain."""

    def __init__(self, sender_address, recipient_address, amount, input_utxos=None):
        self.id = str(uuid4())
        self.sender_address = sender_address
        self.recipient_address = recipient_address
        self.amount = amount
        self.input_utxos = input_utxos or [] # List of UTXOs to be consumed
        self.signature = None
        self.timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def __repr__(self):
        return f"Transaction(ID: {self.id}, From: {self.sender_address[:8]}..., To: {self.recipient_address[:8]}..., Amount: {self.amount})"

    def to_dict(self):
        """Convert transaction to dictionary for JSON serialization"""
        return {
            'tx_id': self.id,
            'sender_address': self.sender_address,
            'recipient_address': self.recipient_address,
            'amount': self.amount,
            'timestamp': self.timestamp,
            'inputs': self.input_utxos,
            'outputs': [],  # Outputs will be empty for now, as they are not explicitly tracked
            'signature': self.signature
        }

    def get_hash(self):
        """Generates a SHA-256 hash of the transaction data."""
        transaction_data_str = json.dumps(self.to_dict(), sort_keys=True)
        return hashlib.sha256(transaction_data_str.encode()).hexdigest()

class UTXO:
    """Represents an unspent transaction output."""
    def __init__(self, tx_id, output_index, amount, recipient_address):
        self.tx_id = tx_id
        self.output_index = output_index
        self.amount = amount
        self.recipient_address = recipient_address

    def to_dict(self):
        return {
            "tx_id": self.tx_id,
            "output_index": self.output_index,
            "amount": self.amount,
            "recipient_address": self.recipient_address
        }

    def __repr__(self):
        return f"UTXO(tx_id: {self.tx_id[:8]}..., amount: {self.amount})"


# --- Block and Blockchain ---

class Block:
    """A single block in the blockchain."""

    def __init__(self, index, previous_hash, transactions, nonce=0):
        self.index = index
        self.timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.transactions = transactions
        self.previous_hash = previous_hash
        self.nonce = nonce
        self.hash = self.calculate_hash()

    def calculate_hash(self):
        """Calculate block hash using dictionary representation"""
        block_dict = {
            'index': self.index,
            'timestamp': self.timestamp,
            'transactions': [tx.to_dict() for tx in self.transactions],
            'previous_hash': self.previous_hash,
            'nonce': self.nonce
        }
        block_string = json.dumps(block_dict, sort_keys=True)
        return hashlib.sha256(block_string.encode()).hexdigest()

    def __repr__(self):
        return f"Block(Index: {self.index}, Hash: {self.hash[:8]}..., Prev Hash: {self.previous_hash[:8]}..., Transactions: {len(self.transactions)})"

class Blockchain:
    """The main blockchain class."""
    
    def __init__(self):
        self.pending_transactions = []
        self.utxo_set = {}  # Global set of unspent transaction outputs
        self.difficulty = 4 # PoW difficulty target
        self.chain = []
        self.block_data_dir = "blockchain_data"
        
        # Create data directory if it doesn't exist
        if not os.path.exists(self.block_data_dir):
            os.makedirs(self.block_data_dir)

        self.load_chain()

        # Create the genesis block if the chain is empty
        if not self.chain:
            self.create_genesis_block()

    def create_genesis_block(self):
        """Creates the first block in the chain."""
        genesis_block = Block(0, "0", [])
        self.chain.append(genesis_block)
        self.save_block(genesis_block)
        print("✅ Genesis Block created.")

    def save_block(self, block):
        """Persists a block to a file."""
        filepath = os.path.join(self.block_data_dir, f"block_{block.index}.pickle")
        with open(filepath, "wb") as f:
            pickle.dump(block, f)

    def load_chain(self):
        """Loads the blockchain from persistent storage."""
        block_files = sorted(glob.glob(os.path.join(self.block_data_dir, "block_*.pickle")), 
                             key=lambda x: int(os.path.basename(x).split('_')[1].split('.')[0]))
        self.chain = []
        if block_files:
            for filepath in block_files:
                with open(filepath, "rb") as f:
                    block = pickle.load(f)
                    self.chain.append(block)
            print(f"Loaded {len(self.chain)} blocks from storage.")

    def get_last_block(self):
        """Returns the last block in the chain."""
        return self.chain[-1]

    def add_transaction(self, transaction):
        """Adds a new transaction to the pool of pending transactions."""
        if not self.validate_transaction(transaction):
            print("❌ Invalid transaction. Rejected.")
            return False
        self.pending_transactions.append(transaction)
        print(f"➕ Transaction added to mempool: {transaction.id}")
        return True

    def mine_block(self, miner_address):
        """Mines a new block using the Proof-of-Work algorithm."""
        print("⛏️ Starting mining process...")

        # Create a coinbase transaction to reward the miner
        coinbase_tx = Transaction(sender_address="blockchain_reward", recipient_address=miner_address, amount=100.0)
        
        # Create a block with pending transactions and the coinbase transaction
        block_transactions = [coinbase_tx] + self.pending_transactions
        
        last_block = self.get_last_block()
        new_block = Block(
            index=last_block.index + 1,
            previous_hash=last_block.hash,
            transactions=block_transactions,
        )

        # Proof-of-Work: Find a hash that meets the difficulty target
        while new_block.hash[:self.difficulty] != '0' * self.difficulty:
            new_block.nonce += 1
            new_block.hash = new_block.calculate_hash()

        # Update the UTXO set and clear the pending transactions
        for tx in block_transactions:
            if tx.sender_address != "blockchain_reward":
                for utxo_in in tx.input_utxos:
                    self.utxo_set.pop((utxo_in['tx_id'], utxo_in['output_index']), None)
            
            output_utxos = {}
            # Assuming a simple model where one output is created per transaction
            utxo_out = UTXO(tx.id, 0, tx.amount, tx.recipient_address)
            self.utxo_set[(utxo_out.tx_id, utxo_out.output_index)] = utxo_out

        self.pending_transactions = []
        self.chain.append(new_block)
        self.save_block(new_block)
        print(f"✅ Block #{new_block.index} mined successfully with nonce: {new_block.nonce}")
        return new_block

    def validate_chain(self):
        """Validates the integrity of the entire blockchain."""
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i-1]

            # Check if the block hash is correct
            if current_block.hash != current_block.calculate_hash():
                print(f"❌ Block {current_block.index} hash is invalid!")
                return False

            # Check if the previous hash is correct
            if current_block.previous_hash != previous_block.hash:
                print(f"❌ Block {current_block.index} previous hash link is broken!")
                return False
        
        print("✅ Blockchain integrity check passed.")
        return True

    def validate_transaction(self, transaction):
        """Validates a transaction, including double-spend prevention."""
        # Check for signature validity
        wallet_manager = Wallet()
        if transaction.sender_address != "blockchain_reward" and not wallet_manager.verify_signature(
            transaction.sender_address, transaction.signature, json.dumps(transaction.to_dict(), sort_keys=True)
        ):
            print("❌ Transaction signature is invalid.")
            return False

        # Double-Spend Prevention using UTXO model
        total_input_amount = 0
        consumed_utxos = set()
        for utxo_in_dict in transaction.input_utxos:
            utxo_key = (utxo_in_dict['tx_id'], utxo_in_dict['output_index'])
            
            # Check if UTXO exists and has not been consumed
            if utxo_key not in self.utxo_set:
                print("❌ Double-spend attempt detected or UTXO not found.")
                return False

            # Check for double-spend within the same transaction
            if utxo_key in consumed_utxos:
                print("❌ Transaction attempts to spend the same UTXO multiple times.")
                return False
            
            consumed_utxos.add(utxo_key)
            total_input_amount += self.utxo_set[utxo_key].amount
        
        if total_input_amount < transaction.amount:
            print("❌ Insufficient funds in UTXOs to cover transaction amount.")
            return False
        
        return True
    
    def get_balance(self, address):
        """Calculates the balance for a given address based on the UTXO set."""
        balance = 0
        for utxo_key, utxo in self.utxo_set.items():
            if utxo.recipient_address == address:
                balance += utxo.amount
        return balance

# --- Main CLI ---

def main():
    blockchain = Blockchain()
    wallets = {}

    while True:
        print("\n--- Blockchain CLI ---")
        print("1. Create New Wallet")
        print("2. Add Transaction")
        print("3. Mine Block")
        print("4. View Blockchain")
        print("5. View Pending Transactions")
        print("6. Check Balance")
        print("7. Exit")
        
        choice = input("Enter your choice: ")
        
        if choice == '1':
            wallet_name = input("Enter wallet name: ")
            wallets[wallet_name] = Wallet()
            print(f"🎉 New wallet '{wallet_name}' created. Address: {wallets[wallet_name].address}")
        
        elif choice == '2':
            if len(wallets) < 2:
                print("❌ You need at least two wallets to create a transaction.")
                continue

            sender_name = input("Enter sender's wallet name: ")
            recipient_name = input("Enter recipient's wallet name: ")
            amount = float(input("Enter amount: "))

            if sender_name not in wallets or recipient_name not in wallets:
                print("❌ Invalid wallet name.")
                continue

            sender_wallet = wallets[sender_name]
            recipient_wallet = wallets[recipient_name]

            # Find UTXOs for the sender
            sender_utxos = [utxo.to_dict() for utxo in blockchain.utxo_set.values() if utxo.recipient_address == sender_wallet.address]
            total_available = sum(utxo['amount'] for utxo in sender_utxos)

            if total_available < amount:
                print("❌ Insufficient funds. Available:", total_available)
                continue

            # Create the transaction
            tx = Transaction(sender_wallet.address, recipient_wallet.address, amount, input_utxos=sender_utxos)
            
            # Sign the transaction
            tx.signature = sender_wallet.sign_transaction(json.dumps(tx.to_dict(), sort_keys=True))
            
            blockchain.add_transaction(tx)

        elif choice == '3':
            miner_name = input("Enter miner's wallet name: ")
            if miner_name not in wallets:
                print("❌ Invalid wallet name.")
                continue
            
            blockchain.mine_block(wallets[miner_name].address)
        
        elif choice == '4':
            print("\n--- Blockchain Contents ---")
            for block in blockchain.chain:
                print(f"Block #{block.index}")
                print(f"  Timestamp: {block.timestamp}")
                print(f"  Hash: {block.hash}")
                print(f"  Previous Hash: {block.previous_hash}")
                print(f"  Nonce: {block.nonce}")
                print("  Transactions:")
                for tx in block.transactions:
                    print(f"    - {tx}")
            print("-" * 20)
        
        elif choice == '5':
            print("\n--- Pending Transactions ---")
            if not blockchain.pending_transactions:
                print("No pending transactions.")
            for tx in blockchain.pending_transactions:
                print(f"  - {tx}")
            print("-" * 20)

        elif choice == '6':
            address_or_name = input("Enter wallet name or address: ")
            if address_or_name in wallets:
                address_to_check = wallets[address_or_name].address
            else:
                address_to_check = address_or_name
            
            balance = blockchain.get_balance(address_to_check)
            print(f"💰 Balance for {address_to_check[:8]}... is: {balance}")

        elif choice == '7':
            print("Exiting.")
            break

if __name__ == "__main__":
    main()
